################################################################################
# DetecciÃ³n y CorrecciÃ³n de Errores usando Hamming (7,4)
# Mg. Ing. Martin Karlo Verastegui Ponce
#
# ImplementaciÃ³n en Python para simular la transmisiÃ³n de datos binarios
# mediante un sistema que utiliza el cÃ³digo Hamming (7,4), capaz de:
# - Codificar los datos
# - Detectar errores de un solo bit
# - Corregir automÃ¡ticamente los errores detectados
# - Decodificar y verificar la integridad de los datos
#
# AplicaciÃ³n Ãºtil para enseÃ±anza, demostraciones de sistemas de transmisiÃ³n,
# redes digitales, telecomunicaciones y sistemas embebidos.
################################################################################

def calcular_bits_paridad(datos):
    d1, d2, d3, d4 = datos
    p1 = (d1 + d2 + d4) % 2
    p2 = (d1 + d3 + d4) % 2
    p3 = (d2 + d3 + d4) % 2
    return [p1, p2, p3]

def codificar_hamming(datos):
    p1, p2, p3 = calcular_bits_paridad(datos)
    d1, d2, d3, d4 = datos
    return [p1, p2, d1, p3, d2, d3, d4]

def detectar_y_corregir(bits):
    p1 = (bits[0] + bits[2] + bits[4] + bits[6]) % 2
    p2 = (bits[1] + bits[2] + bits[5] + bits[6]) % 2
    p3 = (bits[3] + bits[4] + bits[5] + bits[6]) % 2
    posicion_error = p3 * 4 + p2 * 2 + p1
    bits_corregidos = bits[:]
    if posicion_error != 0:
        bits_corregidos[posicion_error - 1] ^= 1
    return posicion_error, bits_corregidos

def decodificar_hamming(bits_corregidos):
    d1 = bits_corregidos[2]
    d2 = bits_corregidos[4]
    d3 = bits_corregidos[5]
    d4 = bits_corregidos[6]
    return [d1, d2, d3, d4]

# --------------------------------------------
# ğŸ”· ENTRADA DE DATOS POR EL USUARIO
# --------------------------------------------
print("ğŸ§  Agente de CorrecciÃ³n Hamming (7,4) v1.0")
print("ğŸ‘¨â€ğŸ« Autor: Mg. Ing. Martin Karlo Verastegui Ponce\n")

while True:
    entrada = input("Ingrese 4 bits separados por espacio (ej: 1 0 1 1): ")
    try:
        datos = list(map(int, entrada.strip().split()))
        if len(datos) == 4 and all(bit in [0, 1] for bit in datos):
            break
        else:
            print("âŒ Ingrese exactamente 4 bits (0 o 1).")
    except:
        print("âŒ Entrada invÃ¡lida. Intente nuevamente.")

# --------------------------------------------
# ğŸ“¦ CODIFICACIÃ“N
# --------------------------------------------
print("\nğŸ“¦ Codificando los datos...")
codificado = codificar_hamming(datos)
print("âœ… Datos codificados (7 bits):", codificado)

# --------------------------------------------
# âš ï¸ SIMULACIÃ“N DE ERROR
# --------------------------------------------
con_error = codificado[:]
con_error[3] ^= 1  # Error simulado en la posiciÃ³n 4
print("âš ï¸ Se ha introducido un error en la posiciÃ³n 4:", con_error)

# --------------------------------------------
# ğŸ› ï¸ DETECCIÃ“N Y CORRECCIÃ“N
# --------------------------------------------
pos_error, corregido = detectar_y_corregir(con_error)
if pos_error:
    print(f"ğŸ› ï¸ Error detectado en la posiciÃ³n {pos_error}. Bit corregido.")
else:
    print("âœ… No se detectaron errores.")

print("ğŸ“¨ Mensaje corregido:", corregido)

# --------------------------------------------
# ğŸ” DECODIFICACIÃ“N FINAL
# --------------------------------------------
datos_decodificados = decodificar_hamming(corregido)
print("ğŸ” Datos decodificados:", datos_decodificados)

# --------------------------------------------
# ğŸ‰ VERIFICACIÃ“N FINAL
# --------------------------------------------
if datos == datos_decodificados:
    print("ğŸ‰ Â¡Ã‰xito! Los datos fueron recuperados correctamente.")
else:
    print("âŒ Los datos no coinciden con los originales.")
